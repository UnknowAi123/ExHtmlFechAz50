<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Analizador de Audio - Versión Completa</title>
  <!-- Cargamos la librería music-metadata-browser desde CDN -->
  <script src="https://cdn.jsdelivr.net/npm/music-metadata-browser/dist/music-metadata-browser.umd.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
    }
    #output {
      margin-top: 20px;
      white-space: pre-wrap;
      text-align: left;
      width: 90%;
      margin: auto;
    }
    #progressBar {
      width: 90%;
      margin: auto;
      height: 20px;
      background: #ccc;
      display: none;
    }
    #progressFill {
      width: 0%;
      height: 100%;
      background: #4caf50;
      transition: width 0.5s;
    }
  </style>
</head>
<body>
  <h1>Analizador de Audio (Completo)</h1>
  <input type="file" id="fileInput" accept=".mp3, .flac, .wav, .ogg, .aac, .m4a">
  <button onclick="exportToHTML()">Exportar Info a HTML</button>
  
  <div id="progressBar">
    <div id="progressFill"></div>
  </div>
  <pre id="output"></pre>
  
  <script>
    document.getElementById('fileInput').addEventListener('change', handleFile);
  
    async function handleFile(event) {
      const file = event.target.files[0];
      if (!file) return;
  
      const progressBar = document.getElementById('progressBar');
      const progressFill = document.getElementById('progressFill');
      progressBar.style.display = 'block';
      progressFill.style.width = '10%';
  
      const output = document.getElementById('output');
      output.textContent = 'Procesando archivo...\n';
  
      try {
        // Paso 1: Extraer metadatos con music-metadata (incluye tags si están presentes)
        progressFill.style.width = '30%';
        const metadata = await musicMetadata.parseBlob(file, { duration: true });
        progressFill.style.width = '50%';
  
        // Paso 2: Leer el archivo completo para obtener ArrayBuffer (para hash y AudioContext)
        const fileBuffer = await file.arrayBuffer();
  
        // Paso 3: Decodificar el audio mediante AudioContext para obtener datos técnicos (duración, canales, etc.)
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const audioBuffer = await audioContext.decodeAudioData(fileBuffer);
        progressFill.style.width = '70%';
  
        // Paso 4: Generar el hash SHA-256 del archivo
        const hash = await generateHash(fileBuffer);
        progressFill.style.width = '80%';
  
        // Paso 5: Construir el resultado combinando información básica del archivo, metadatos y datos técnicos.
        let result = '';
        // Información básica obtenida del objeto File
        result += `Archivo       : ${file.name}\n`;
        result += `Tamaño (KB)   : ${(file.size / 1024).toFixed(2)} KB\n`;
        result += `Tipo          : ${file.type || 'No disponible'}\n\n`;
  
        // Metadatos (tags) extraídos con music-metadata
        result += '--- METADATOS (Tags) ---\n';
        result += `Título        : ${metadata.common.title || 'No disponible'}\n`;
        result += `Artista       : ${metadata.common.artist || 'No disponible'}\n`;
        result += `Álbum         : ${metadata.common.album || 'No disponible'}\n`;
        result += `Género(s)     : ${(metadata.common.genre && metadata.common.genre.join(', ')) || 'No disponible'}\n\n`;
  
        // Información técnica (datos obtenidos tanto de metadata.format como del AudioContext)
        result += '--- INFORMACIÓN TÉCNICA ---\n';
        // Duración: preferimos lo que indique metadata; si no existe, usamos el valor de AudioContext
        if (metadata.format.duration) {
          result += `Duración      : ${metadata.format.duration.toFixed(2)} s\n`;
        } else if (audioBuffer.duration) {
          result += `Duración (AC): ${audioBuffer.duration.toFixed(2)} s\n`;
        } else {
          result += 'Duración      : No disponible\n';
        }
        // Otros datos técnicos
        result += `Bitrate       : ${metadata.format.bitrate ? metadata.format.bitrate + ' bps' : 'No disponible'}\n`;
        result += `Frecuencia    : ${metadata.format.sampleRate || 'No disponible'} Hz\n`;
        result += `Canales       : ${metadata.format.numberOfChannels || 'No disponible'}\n`;
        result += `Contenedor    : ${metadata.format.container || file.type || 'No disponible'}\n`;
        result += `Codec         : ${metadata.format.codec || 'No disponible'}\n`;
        if (metadata.format.bitsPerSample)
          result += `Bits/Sample   : ${metadata.format.bitsPerSample}\n`;
  
        result += `\nHash SHA-256  : ${hash}\n`;
  
        output.textContent = result;
        progressFill.style.width = '100%';
  
        setTimeout(() => { progressBar.style.display = 'none'; }, 1000);
      } catch (error) {
        console.error(error);
        output.textContent = 'Error al procesar el archivo. Verifica que tenga metadatos y que sea un formato compatible.\n' + error;
        progressBar.style.display = 'none';
      }
    }
  
    async function generateHash(buffer) {
      const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
      return Array.from(new Uint8Array(hashBuffer))
        .map(b => b.toString(16).padStart(2, '0'))
        .join('');
    }
  
    function exportToHTML() {
      const content = document.getElementById('output').textContent;
      const blob = new Blob([`<pre>${content}</pre>`], { type: 'text/html' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'audio_info.html';
      a.click();
    }
  </script>
</body>
</html>
