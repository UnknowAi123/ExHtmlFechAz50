<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Reproductor Mejorado</title>
  <style>
    /* Estilos generales */
    body {
      font-family: sans-serif;
      margin: 20px;
    }
    h1 {
      margin-bottom: 10px;
    }
    /* Contenedor del reproductor (audio y/o Youtube) */
    #playerContainer {
      margin-bottom: 15px;
    }
    /* Controles básicos */
    #controls {
      margin-bottom: 15px;
    }
    button {
      margin-right: 10px;
      padding: 5px 10px;
    }
    /* Lista de pistas */
    #playlist {
      list-style: none;
      padding: 0;
      margin: 0;
    }
    #playlist li {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 5px;
      border-bottom: 1px solid #ccc;
      cursor: pointer;
    }
    /* Punto 4: Truncamiento de nombres largos */
    .track-info {
      overflow: hidden;
      white-space: nowrap;
      text-overflow: ellipsis;
      /* Se asigna un ancho dinámico: se reserva espacio para el icono de la papelera */
      max-width: calc(100% - 40px);
    }
    .trashIcon {
      margin-left: 10px;
      cursor: pointer;
    }
    .active {
      background-color: #eee;
    }
  </style>
</head>
<body>
  <h1>Reproductor Mejorado</h1>
  
  <!-- Contenedor del reproductor: aquí se usará un elemento audio para pistas locales y un contenedor para YouTube -->
  <div id="playerContainer">
    <audio id="localAudio" controls style="display: none;"></audio>
    <div id="youtubeContainer" style="display: none;">
      <div id="youtubePlayer"></div>
    </div>
  </div>
  
  <!-- Controles del reproductor -->
  <div id="controls">
    <button id="prevBtn">Anterior</button>
    <button id="playPauseBtn">Play</button>
    <button id="nextBtn">Siguiente</button>
    <button id="shuffleBtn">Shuffle Off</button>
  </div>
  
  <!-- Listado de pistas -->
  <ul id="playlist"></ul>
  
  <!-- Se carga la API de YouTube para manejar videos -->
  <script src="https://www.youtube.com/iframe_api"></script>
  <script>
    /********************
     * Variables Globales
     ********************/
    let playlist = [
      // Ejemplos de pistas; algunas son locales y otras de YouTube.
      { 
        type: 'local', 
        name: 'Canción Local Corto', 
        url: 'song1.mp3', 
        artist: 'Artista Local', 
        title: 'Canción 1' 
      },
      { 
        type: 'youtube', 
        name: 'Video de YouTube', 
        url: 'dQw4w9WgXcQ', 
        artist: 'Artista YT', 
        title: 'Canción YT' 
      },
      { 
        type: 'local', 
        name: 'Canción Local con Nombre Muy Largo que debería truncarse en vista responsiva', 
        url: 'song2.mp3', 
        artist: 'Artista Largo', 
        title: 'Una Canción Increíblemente Larga de Nombre' 
      },
      { 
        type: 'local', 
        name: 'Otra Canción', 
        url: 'song3.mp3', 
        artist: 'Otro Artista', 
        title: 'Otra Canción' 
      },
      { 
        type: 'youtube', 
        name: 'Otro Video de YouTube', 
        url: '9bZkp7q19f0', 
        artist: 'Gangnam Style', 
        title: 'Gangnam Style' 
      },
      { 
        type: 'local', 
        name: 'Canción 4', 
        url: 'song4.mp3', 
        artist: 'Artista 4', 
        title: 'Canción 4' 
      },
      { 
        type: 'local', 
        name: 'Canción 5', 
        url: 'song5.mp3', 
        artist: 'Artista 5', 
        title: 'Canción 5' 
      }
    ];
    
    let currentIndex = 0;
    let shuffleMode = false;
    let recentHistory = [];  // (Punto 1) Historial de las últimas 6 canciones reproducidas en modo shuffle.
    let userPaused = false;  // Flag para distinguir pausas intencionadas por el usuario.
    
    // Referencias a elementos del DOM
    const playlistUI = document.getElementById('playlist');
    const playPauseBtn = document.getElementById('playPauseBtn');
    const prevBtn = document.getElementById('prevBtn');
    const nextBtn = document.getElementById('nextBtn');
    const shuffleBtn = document.getElementById('shuffleBtn');
    const localAudio = document.getElementById('localAudio');
    const youtubeContainer = document.getElementById('youtubeContainer');
    let youtubePlayer = null; // Se inicializará mediante la API de YouTube.

    /*********************************
     * Integración con Media Session API
     *********************************/
    function updateMediaSession() {
      if ('mediaSession' in navigator) {
        const currentItem = playlist[currentIndex];
        navigator.mediaSession.metadata = new MediaMetadata({
          title: currentItem.title || currentItem.name,
          artist: currentItem.artist || '',
          album: '',
          artwork: [] // Si ya se obtiene la carátula automáticamente, se puede dejar vacía.
        });
        navigator.mediaSession.setActionHandler('play', playCurrentTrack);
        navigator.mediaSession.setActionHandler('pause', pauseCurrentTrack);
        navigator.mediaSession.setActionHandler('previoustrack', prevTrack);
        navigator.mediaSession.setActionHandler('nexttrack', nextTrack);
      }
    }

    /****************************
     * Carga y reproductor actual
     ****************************/
    function loadCurrentTrack() {
      const track = playlist[currentIndex];

      // Ocultamos ambos reproductores antes de mostrar el adecuado.
      localAudio.style.display = 'none';
      youtubeContainer.style.display = 'none';

      if (track.type === 'local') {
        localAudio.src = track.url;
        localAudio.style.display = 'block';
      } else if (track.type === 'youtube') {
        youtubeContainer.style.display = 'block';
        // Si ya hay un reproductor de YouTube, se carga el video; de lo contrario, se cargará al inicializar la API.
        if (youtubePlayer && typeof youtubePlayer.loadVideoById === 'function') {
          youtubePlayer.loadVideoById(track.url);
        }
      }
      updateMediaSession();
      updatePlaylistUI();
    }

    function playCurrentTrack() {
      userPaused = false;
      const track = playlist[currentIndex];
      if (track.type === 'local') {
        localAudio.play();
      } else if (track.type === 'youtube') {
        if (youtubePlayer && typeof youtubePlayer.playVideo === 'function') {
          youtubePlayer.playVideo();
        }
      }
      playPauseBtn.textContent = 'Pause';
    }

    function pauseCurrentTrack() {
      userPaused = true;
      const track = playlist[currentIndex];
      if (track.type === 'local') {
        localAudio.pause();
      } else if (track.type === 'youtube') {
        if (youtubePlayer && typeof youtubePlayer.pauseVideo === 'function') {
          youtubePlayer.pauseVideo();
        }
      }
      playPauseBtn.textContent = 'Play';
    }

    /**************************************
     * (Punto 1) Modo Shuffle sin repetición
     **************************************/
    function getNextShuffleIndex() {
      let allowedIndices = [];
      playlist.forEach((item, i) => {
        // Se excluye la pista actual y las que ya figuran en el historial reciente.
        if(i !== currentIndex && recentHistory.indexOf(i) === -1) {
          allowedIndices.push(i);
        }
      });
      // Si no hay índices permitidos, se resetea el historial (excepto cuando la playlist es muy corta)
      if (allowedIndices.length === 0) {
        if (playlist.length > 1) {
          recentHistory = [];
          allowedIndices = playlist.map((_, i) => i).filter(i => i !== currentIndex);
        } else {
          return currentIndex; // Solo hay una pista.
        }
      }
      return allowedIndices[Math.floor(Math.random() * allowedIndices.length)];
    }

    function nextTrack() {
      if (shuffleMode) {
        currentIndex = getNextShuffleIndex();
        recentHistory.push(currentIndex);
        if (recentHistory.length > 6) {
          recentHistory.shift();
        }
      } else {
        currentIndex = (currentIndex + 1) % playlist.length;
      }
      loadCurrentTrack();
      playCurrentTrack();
    }

    function prevTrack() {
      if (shuffleMode) {
        // En modo shuffle se puede utilizar la misma lógica que para "siguiente"
        currentIndex = getNextShuffleIndex();
        recentHistory.push(currentIndex);
        if (recentHistory.length > 6) {
          recentHistory.shift();
        }
      } else {
        currentIndex = (currentIndex - 1 + playlist.length) % playlist.length;
      }
      loadCurrentTrack();
      playCurrentTrack();
    }

    /*************************************
     * (Punto 2) Eliminación de pistas
     *************************************/
    function removeFromPlaylist(index) {
      playlist.splice(index, 1);
      if (index === currentIndex) {
        // Si se elimina la pista actual, se detiene la reproducción
        pauseCurrentTrack();
        if (playlist.length > 0) {
          // Se ajusta el índice (por ejemplo, se toma la pista siguiente)
          currentIndex = index % playlist.length;
          loadCurrentTrack();
        } else {
          // Sin pistas, se detiene y limpia el reproductor.
          localAudio.pause();
          localAudio.src = "";
          if (youtubePlayer) {
            youtubePlayer.stopVideo();
          }
        }
      } else if (index < currentIndex) {
        currentIndex--; // Se ajusta el índice si se elimina una pista anterior a la actual.
      }
      updatePlaylistUI();
    }

    /**********************************************
     * (Puntos 3 y 6) Actualización del listado de pistas
     **********************************************/
    function updatePlaylistUI() {
      playlistUI.innerHTML = '';
      playlist.forEach((item, index) => {
        const li = document.createElement('li');

        // Se encapsula la información en un span que aplicará el truncamiento responsivo.
        const trackInfo = document.createElement('span');
        trackInfo.classList.add('track-info');
        if (item.artist && item.title) {
          trackInfo.textContent = item.artist + " - " + item.title;
        } else {
          trackInfo.textContent = item.name;
        }
        li.appendChild(trackInfo);

        // Ícono de papelera para eliminar la pista (Punto 2)
        const trash = document.createElement('span');
        trash.textContent = " 🗑️";
        trash.classList.add("trashIcon");
        trash.addEventListener('click', (e) => {
          e.stopPropagation();
          removeFromPlaylist(index);
        });
        li.appendChild(trash);

        li.addEventListener('click', () => {
          currentIndex = index;
          loadCurrentTrack();
          playCurrentTrack();
        });
        if (index === currentIndex) {
          li.classList.add('active');
        }
        playlistUI.appendChild(li);
      });
    }

    /*********************************
     * Eventos de Controles del Reproductor
     *********************************/
    playPauseBtn.addEventListener('click', () => {
      const track = playlist[currentIndex];
      if (track.type === 'local') {
        if (localAudio.paused) {
          playCurrentTrack();
        } else {
          pauseCurrentTrack();
        }
      } else if (track.type === 'youtube') {
        // Semántica basada en el texto del botón
        if (playPauseBtn.textContent === 'Play') {
          playCurrentTrack();
        } else {
          pauseCurrentTrack();
        }
      }
    });

    prevBtn.addEventListener('click', prevTrack);
    nextBtn.addEventListener('click', nextTrack);

    shuffleBtn.addEventListener('click', () => {
      shuffleMode = !shuffleMode;
      shuffleBtn.textContent = shuffleMode ? 'Shuffle On' : 'Shuffle Off';
      // Al activar/desactivar shuffle se resetea el historial
      recentHistory = [];
    });

    /******************************
     * Integración con la API de YouTube
     ******************************/
    function onYouTubeIframeAPIReady() {
      youtubePlayer = new YT.Player('youtubePlayer', {
        height: '360',
        width: '640',
        videoId: (playlist[currentIndex].type === 'youtube' ? playlist[currentIndex].url : ''),
        events: {
          'onReady': onPlayerReady,
          'onStateChange': onPlayerStateChange
        },
        playerVars: {
          'playsinline': 1,
          'autoplay': 0,
          'controls': 1
        }
      });
    }

    function onPlayerReady(event) {
      // Puede reproducirse automáticamente o esperar acción
    }

    function onPlayerStateChange(event) {
      // Si el video termina, se avanza a la siguiente pista.
      if (event.data === YT.PlayerState.ENDED) {
        nextTrack();
      }
    }

    /************************************
     * Inicialización al cargar la página
     ************************************/
    loadCurrentTrack();
    updatePlaylistUI();

    /* 
      Notar que respecto a la continuidad de la reproducción al salir/entrar a Firefox,
      decidimos no intervenir directamente en los eventos de visibilidad para evitar breves pausas.
      El comportamiento se mantiene de manera fluida mientras no se cierre el navegador o la pantalla.
    */
  </script>
</body>
</html>
