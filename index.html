<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Juego de Memoria de Colores - Umbrales Funcionando</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    /* Reset y estilos básicos */
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { font-family: Arial, sans-serif; background: #fff; text-align: center; }
    h1 { margin: 20px 0; font-size: 20px; }
    .grid-container { width: 100%; max-width: 600px; margin: 20px auto; }
    .grid { display: grid; grid-template-columns: repeat(8, 1fr); gap: 4px; }
    .cell { position: relative; background: #ccc; padding-bottom: 100%; cursor: pointer; transition: all 0.3s; }
    .cell > div { position: absolute; top: 0; left: 0; right: 0; bottom: 0; }
    .cell.selected { border: 3px solid #FFD700; transform: scale(1.05); }
    .cell.removed { opacity: 0; pointer-events: none; }
  </style>
</head>
<body>
  <h1>Juego de Memoria de Colores - Modo Hexadecimal con Umbrales</h1>
  <div class="grid-container">
    <div class="grid" id="grid"></div>
  </div>

  <script>
    // Función para convertir valores RGB a hexadecimal
    function rgbToHex(r, g, b) {
      function toHex(c) {
        const hex = c.toString(16);
        return hex.length === 1 ? "0" + hex : hex;
      }
      return "#" + toHex(r) + toHex(g) + toHex(b);
    }
    
    // Genera un color pastel en RGB y lo devuelve en un objeto con propiedades r, g, b y hex.
    function getRandomPastelHex() {
      // Se genera un valor aleatorio y se mezcla con 255 para acercarlo a blanco, obteniendo un tono pastel.
      const r = Math.floor((Math.random() * 256 + 255) / 2);
      const g = Math.floor((Math.random() * 256 + 255) / 2);
      const b = Math.floor((Math.random() * 256 + 255) / 2);
      return { r: r, g: g, b: b, hex: rgbToHex(r, g, b) };
    }
    
    // Calcula la distancia euclidiana entre dos colores en el espacio RGB.
    function colorDistance(c1, c2) {
      const dr = c1.r - c2.r;
      const dg = c1.g - c2.g;
      const db = c1.b - c2.b;
      return Math.sqrt(dr * dr + dg * dg + db * db);
    }
    
    // Umbral para determinar si dos colores son demasiado similares.
    // Puedes ajustar este valor para que "funcione" como deseas.
    const rgbThreshold = 40;
    
    // Devuelve true si la distancia entre dos colores es menor que el umbral.
    function areColorsSimilarRGB(color1, color2) {
      return colorDistance(color1, color2) < rgbThreshold;
    }
    
    // Genera 44 colores únicos (cada uno duplicado para formar 88 celdas).
    // Se realizan hasta 10 intentos para que un color no sea demasiado similar a alguno ya generado.
    function generateColors() {
      const colors = [];
      for (let i = 0; i < 44; i++) {
        let color, attempt = 0;
        do {
          color = getRandomPastelHex();
          attempt++;
        } while (colors.some(c => areColorsSimilarRGB(c, color)) && attempt < 10);
        // Se duplica el color para formar un par.
        colors.push(color, color);
      }
      return colors;
    }
    
    // Algoritmo de shuffle (Fisher-Yates) para mezclar los colores.
    function shuffle(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
    }
    
    // Manejo de la cuadrícula y la mecánica de juego (selección de celdas).
    const grid = document.getElementById("grid");
    let firstCell = null, secondCell = null, lockBoard = false;
    
    function initGame() {
      grid.innerHTML = "";
      const colors = generateColors();
      shuffle(colors);
      // Se crean 88 celdas.
      for (let i = 0; i < 88; i++) {
        const cell = document.createElement("div");
        cell.classList.add("cell");
        const innerDiv = document.createElement("div");
        innerDiv.style.backgroundColor = colors[i].hex;
        cell.dataset.color = colors[i].hex;
        cell.appendChild(innerDiv);
        cell.addEventListener("click", handleCellClick);
        grid.appendChild(cell);
      }
    }
    
    function handleCellClick() {
      if (lockBoard || this.classList.contains("removed")) return;
      if (this === firstCell) return;
      
      this.classList.add("selected");
      
      if (!firstCell) {
        firstCell = this;
      } else {
        secondCell = this;
        lockBoard = true;
        if (firstCell.dataset.color === secondCell.dataset.color) {
          setTimeout(() => {
            firstCell.classList.add("removed");
            secondCell.classList.add("removed");
            firstCell.classList.remove("selected");
            secondCell.classList.remove("selected");
            resetSelection();
          }, 200);
        } else {
          setTimeout(() => {
            firstCell.classList.remove("selected");
            secondCell.classList.remove("selected");
            resetSelection();
          }, 200);
        }
      }
    }
    
    function resetSelection() {
      firstCell = null;
      secondCell = null;
      lockBoard = false;
    }
    
    // Inicia el juego al cargar la página.
    initGame();
  </script>
</body>
</html>
