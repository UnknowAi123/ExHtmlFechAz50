<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Reproductor de Música HTML</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
    }
    #controls {
      margin-bottom: 15px;
    }
    button {
      padding: 10px 15px;
      margin: 5px;
      font-size: 16px;
    }
    #playlist {
      list-style: none;
      padding: 0;
    }
    #playlist li {
      padding: 5px;
      cursor: pointer;
    }
    #playlist li.active {
      background-color: #ddd;
    }
    #volumeControl {
      margin: 10px 0;
    }
  </style>
  
  <!-- Librería jsmediatags para leer metadatos (ID3) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jsmediatags/3.9.7/jsmediatags.min.js"></script>
</head>
<body>
  <h1>Reproductor de Música</h1>
  <div id="fileSelection">
    <!-- Se permite seleccionar archivos o carpetas (webkitdirectory en navegadores basados en Chromium) -->
    <input type="file" id="fileInput" multiple webkitdirectory accept="audio/*">
  </div>
  
  <div id="controls">
    <button id="prevButton">Anterior</button>
    <button id="playButton">Play</button>
    <button id="pauseButton">Pause</button>
    <button id="nextButton">Siguiente</button>
    <button id="shuffleToggle">Shuffle Off</button>
    <button id="exportPlaylist">Exportar Playlist (HTML)</button>
  </div>
  
  <div id="volumeControl">
    <label for="volumeSlider">Volumen: </label>
    <input type="range" id="volumeSlider" min="0" max="100" value="100">
  </div>
  
  <ul id="playlist"></ul>
  
  <!-- Elemento de audio (sin controles nativos para personalizar la interfaz) -->
  <audio id="audioPlayer"></audio>
  
  <script>
    // Variables globales
    let playlist = []; // Array de objetos: { name, url, artist, album }
    let currentIndex = 0;
    let shuffleOn = false;
    const audioPlayer = document.getElementById('audioPlayer');
    const fileInput = document.getElementById('fileInput');
    const playlistUI = document.getElementById('playlist');
    const playButton = document.getElementById('playButton');
    const pauseButton = document.getElementById('pauseButton');
    const prevButton = document.getElementById('prevButton');
    const nextButton = document.getElementById('nextButton');
    const shuffleToggle = document.getElementById('shuffleToggle');
    const exportPlaylistButton = document.getElementById('exportPlaylist');
    const volumeSlider = document.getElementById('volumeSlider');
    
    // Actualiza la visualización de la playlist
    function updatePlaylistUI() {
      playlistUI.innerHTML = '';
      playlist.forEach((item, index) => {
        const li = document.createElement('li');
        // Si se han leído los metadatos, se muestran; sino, se usa el nombre del archivo
        let displayText = item.name;
        if (item.artist || item.album) {
          displayText = `${item.name} - ${item.artist || 'Desconocido'} - ${item.album || 'Desconocido'}`;
        }
        li.textContent = displayText;
        li.dataset.index = index;
        if (index === currentIndex) li.classList.add('active');
        li.addEventListener('click', () => {
          currentIndex = index;
          loadCurrentTrack();
          playCurrentTrack();
          updatePlaylistUI();
        });
        playlistUI.appendChild(li);
      });
    }
    
    // Cargar la pista actual en el reproductor
    function loadCurrentTrack() {
      if (playlist[currentIndex]) {
        audioPlayer.src = playlist[currentIndex].url;
      }
    }
    
    // Funciones de control de reproducción
    function playCurrentTrack() {
      audioPlayer.play();
      updatePlaylistUI();
    }
    
    function pauseCurrentTrack() {
      audioPlayer.pause();
    }
    
    function nextTrack() {
      if (shuffleOn) {
        currentIndex = Math.floor(Math.random() * playlist.length);
      } else {
        currentIndex = (currentIndex + 1) % playlist.length;
      }
      loadCurrentTrack();
      playCurrentTrack();
    }
    
    function prevTrack() {
      if (shuffleOn) {
        currentIndex = Math.floor(Math.random() * playlist.length);
      } else {
        currentIndex = (currentIndex - 1 + playlist.length) % playlist.length;
      }
      loadCurrentTrack();
      playCurrentTrack();
    }
    
    // Event listeners de botones de controles
    playButton.addEventListener('click', () => {
      if (!audioPlayer.src && playlist.length > 0) {
        loadCurrentTrack();
      }
      playCurrentTrack();
    });
    
    pauseButton.addEventListener('click', pauseCurrentTrack);
    nextButton.addEventListener('click', nextTrack);
    prevButton.addEventListener('click', prevTrack);
    
    shuffleToggle.addEventListener('click', () => {
      shuffleOn = !shuffleOn;
      shuffleToggle.textContent = shuffleOn ? 'Shuffle On' : 'Shuffle Off';
    });
    
    // Exportar la playlist en formato HTML
    exportPlaylistButton.addEventListener('click', () => {
      if (playlist.length === 0) return;
      let htmlContent = `
<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Playlist Exportada</title>
  <style>
    body { font-family: Arial, sans-serif; }
    h1 { text-align: center; }
    ul { list-style: none; padding: 0; }
    li { padding: 5px; }
  </style>
</head>
<body>
  <h1>Playlist Exportada</h1>
  <ul>
    ${playlist
      .map(
        item =>
          `<li>${item.name} - ${item.artist || 'Desconocido'} - ${item.album || 'Desconocido'}</li>`
      )
      .join('')}
  </ul>
</body>
</html>`;
      const blob = new Blob([htmlContent], { type: 'text/html' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'playlist.html';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
    });
    
    // Reproducir siguiente pista al terminar la actual
    audioPlayer.addEventListener('ended', nextTrack);
    
    // Control del volumen. El valor del slider (0 a 100) se convierte a [0,1]
    volumeSlider.addEventListener('input', () => {
      audioPlayer.volume = volumeSlider.value / 100;
    });
    
    // Función auxiliar para barajar un array (algoritmo Fisher-Yates)
    function shuffleArray(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
    }
    
    // Al seleccionar archivos, se crea la playlist
    fileInput.addEventListener('change', (event) => {
      const files = event.target.files;
      playlist = [];
      currentIndex = 0;
      // Filtramos: solo se dejan los archivos cuyo tipo comienza con "audio"
      const audioFiles = Array.from(files).filter(file => file.type.startsWith('audio'));
      
      audioFiles.forEach(file => {
        const url = URL.createObjectURL(file);
        // Objeto con información básica; se actualizará con los metadatos si están disponibles.
        const song = {
          name: file.name,
          artist: '',
          album: '',
          url: url
        };
        // Usar jsmediatags para leer las etiquetas ID3 y actualizar la información si es posible
        jsmediatags.read(file, {
          onSuccess: function(tag) {
            const tags = tag.tags;
            if (tags.title) song.name = tags.title;
            if (tags.artist) song.artist = tags.artist;
            if (tags.album) song.album = tags.album;
            updatePlaylistUI();
          },
          onError: function(error) {
            console.log('Error leyendo ID3 tags: ', error);
          }
        });
        playlist.push(song);
      });
      
      if (shuffleOn) {
        shuffleArray(playlist);
      }
      updatePlaylistUI();
      if (playlist.length > 0) {
        loadCurrentTrack();
      }
    });
    
  </script>
</body>
</html>
